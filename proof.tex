\chapter{証明機構}

本章では、Actarioでのアクターシステムに関する命題の定義方法およびその証明の機構について説明する。
まず遷移パスを使って行う\fairness の形式化について説明する。
次に\fairness の形式化を行う際に用いた、この先いつかある事柄が成り立つ、というような述語を使って、初期状態からいつか必ずあるラベルで遷移するというような性質を表す述語を定義する。
その後、証明を行う際に用いる遷移可能なラベルと遷移後の配置を計算するための関数について説明し、
最後に遷移パスをつかって証明を行う方法について説明する。

\section{\fairness の形式化}
\fairness とは、アクターモデルが持つ性質で、遷移しうるラベルは必ずいつかそのラベルで遷移するというものである。
アクターモデルでは必ず\fairness が成り立っており、これを前提としなければ証明できない性質もあるため、まず\fairness の形式化を行う。
また、\fairness を形式化する際に使う、この先いつかある事柄が成り立つ、というような述語はActarioの証明機構でも使っているので、その説明も行う。

通常、\fairness を表現する際には時相論理が必要になるが、Coqは時相論理はサポートしていない。
そのため、配置の遷移列である遷移パスを使って\fairness を表現する。
この手法はAppl$\pi$\cite{}で用いられている手法である。Appl$\pi$は$\pi$計算のためのライブラリであるが、\fairness の定義方法についてはアクターモデルに対しても同様に用いることができる。

\subsection{遷移パス}
遷移パスは自然数$\mathbb{N}$から\texttt{option config}型への関数として定義する (図~\ref{code:formalization:path})。
定義域の自然数は、初期状態から何回目の遷移によってこの配置になったかという番号である。この番号をインデックスと呼ぶ。
値域はそのインデックスに対応する配置を表す。\texttt{config}型ではなく\texttt{option config}型になっているのは、これ以上遷移ができないパスも表したいからである。つまり、これ以上遷移ができない配置のインデックスを$n$とすると、$\forall m > 0, n + m$に遷移パス関数を適用した結果は\texttt{None}になる。

\begin{figure}[tp]
  \begin{lstlisting}
    Definition path := nat -> option config.
  \end{lstlisting}
  \label{code:formalization:path}
  \caption{遷移パスの定義}
\end{figure}

また、与えられた遷移パスが確かに遷移パスとしての仕様を満たしているか、という述語を定義する(図~\ref{code:formalization:path-spec})。
すべてのインデックス$i$について、$i$番目の配置が存在するならば、$i+1$番目の配置が存在するならそれは遷移できるものか、それ以上遷移できない。$i$番目の配置が存在しないならば、その次の配置も存在しない、という意味である。

\begin{figure}[tp]
  \begin{lstlisting}
Definition is_transition_path (p : path) : Prop :=
  forall n,
    (forall c, p n = Some c ->
      (exists c' l, p (S n) = Some c' /\
        c ~(l)~> c') \/
      p (S n) = None) /\
    (p n = None -> p (S n) = None).
  \end{lstlisting}
  \label{code:formalization:path-spec}
  \caption{遷移パスの仕様}
\end{figure}

\subsection{遷移可能性}
次に、与えられた配置が与えられたラベルでもって遷移ができるという述語を定義する。これを遷移可能性(enabled)と呼ぶ。
Actarioでは、遷移可能性はある配置からあるラベルによって遷移した先の配置が存在すると定義する (図~\ref{code:formalization:enabled})。

\begin{figure}[tp]
  \begin{lstlisting}
Definition enabled (c : config) (l : label) : Prop := exists c', c ~(l)~> c'.
  \end{lstlisting}
  \label{code:formalization:enabled}
  \caption{遷移可能性}
\end{figure}

\subsection{Infinitely Often Enabled}
無限にしばしば遷移可能になる
We define the predicate that the transition is infinitely often enabled in the transition path.
It is named \texttt{infinitely often enabled}.
%% これは、すべての index n について、n 番目の configuration があるラベルによって遷移が可能ならば、その先そのラベルによって遷移が可能になる configuration が存在する、と定義する。

\begin{lstlisting}
Definition infinitely_often_enabled
    (l : label) (p : path) : Prop :=
  forall n c, p n = Some c ->
    enabled c l ->
    exists m c', m > n /\
      p m = Some c' /\
      enabled c' l.
\end{lstlisting}


\subsection{Eventually Processed}
We define \texttt{eventually processed} that is the predicate of label and transition path.
It represents that the transition with the label is processed eventually in the path.
It is defined as follows.

\begin{lstlisting}
Definition eventually_processed
    (l : label) (p : path) : Prop :=
  exists n c c',
    p n = Some c /\
    p (S n) = Some c' /\
    c ~(l)~> c'.
\end{lstlisting}


\subsection{Fairness}
\texttt{fairness}という制約は、図\ref{code:formalization:fairness}のように定義できる。

任意の遷移パス
For the given transition path and for each label, if \texttt{infinitely often enabled} holds, then \texttt{eventually processed} holds.
\texttt{is\_postfix\_ of} という述語は、無限を表すために使われており、。

If \texttt{is postfix of} is not used, the transition may not be processed after the transition is processed although the transition is processed in whole the path.
To prevent it, if \texttt{inifinitely often enabled} holds then \texttt{eventually processed} holds for arbitrary postfix path by using \texttt{is postfix path}.

\begin{figure}
\begin{lstlisting}
Definition is_postfix_of (p' p : path) : Prop :=
  exists n, (forall m, p' m = p (m + n)).

Definition fairness : Prop :=
  forall p p', is_postfix_of p' p ->
    (forall l,
      infinitely_often_enabled l p' ->
      eventually_processed l p').
\end{lstlisting}
\label{code:formalization:fairness}
\caption{\fairness の定義}
\end{figure}

\section{命題の定義}

アクターモデルのアプリケーションの性質を表す際に便利な述語を、前節で定義した\coqi{eventually_processed}を使って定義する。

\section{遷移可能なラベルと遷移後の配置の計算}

証明の方針としては、
配置から遷移可能なラベルの集合、配置から各ラベルによって遷移した後の配置は決定可能であることに着目する。
関数として定義する理由は、遷移可能なラベルと遷移後の配置を計算可能にすることによって、ユーザが配置の内容を書き出さずに遷移パスを追えるようにするためである。
これはSsreflectの考え方と同一である。

\subsection{遷移可能なラベルの計算}

(TODO)
配置はアクターの集合として表されており、また、\ref{chapter:formalization}で説明したように、各アクターの名前は必ず一意となる。
ラベルはアクター型の\coqi{remaining_actions}フィールドにある\coqi{actions}型の値に一対一になっているため、各アクターはアクションを行って遷移を行うか、遷移できないかのどちらかになる。
よって、配置からラベルの集合への関数を作ることができる。
この関数を\coqi{possible_labels}と呼ぶことにする。
\coqi{possible_labels}の定義は図\ref{code:proof:possible-labels}のようになる。\coqi{cat_options}はヘルパー関数で、\coqi{option A}型のリストを、\coqi{Some}の場合だけ抜き出したようなリストに変換する関数である。

\begin{figure}
\begin{lstlisting}
Fixpoint cat_options {A : Type} (opts : seq (option A)) :=
  match opts with
  | [::] => [::]
  | None :: opts' => cat_options opts'
  | Some a :: opts' => a :: cat_options opts'
  end.

Definition possible_labels (c : config) : seq label :=
  cat_options (map (fun a =>
    match a with
    | {| actor_name := to; remaining_actions := become _; queue := msg :: msgs |} =>
      Some (Receive to msg)
    | {| actor_name := fr; remaining_actions := send to msg _ |} =>
      if to \in (map actor_name c) then Some (Send fr to msg) else None
    | {| actor_name := p; remaining_actions := new _ temp ini _; next_num := nx |} =>
      Some (New (generated nx p))
    | {| actor_name := me; remaining_actions := self _ |} =>
      Some (Self me)
    | _ => None
   end) c).
\end{lstlisting}
\label{code:proof:possible-labels}
\caption{\coqi{possible_labels}の定義}
\end{figure}

計算結果のラベルのリストが確かに網羅されているかということは、まだ証明できておらず、今後の課題となっている。

\subsection{遷移後の配置の計算}

ラベルとそのラベルによって遷移した後の配置は集合として同型となるものを除いて一意となるため、関数として定義できる。

関数定義は煩雑であるため載せない。

計算結果の配置が確かにもとの配置からそのラベルによって遷移したものになっているということはまだ証明できておらず、今後の課題となっている。

\subsection{trace path}

遷移パスを追うための補題を用意する。

\begin{figure}
\begin{lstlisting}
Fixpoint any1 {A : Type} (p : A -> Prop) (d : Prop) (s : seq A) :=
  match s with
  | [::] => d
  | [:: h] => p h
  | h :: t => p h \/ any1 p d t
  end.

Lemma trace_path :
  forall p i c,
    is_transition_path p ->
    p i = Some c ->
    any1 (fun l => p (S i) = Some (calc_trans c l)) (* exhaustive by path_perm *)
         (p (S i) = None)                      (* if possible_labels is empty *)
         (possible_labels c).
\end{lstlisting}
\label{code:proof:trace-path}
\caption{\coqi{trace_path}の定義}
\end{figure}

これは、ある遷移パスについて、$i + 1$番目の配置は$i$番目の配置から遷移可能であるもののいずれかである、という意味である。
この際、集合としては同型でもリストとしては異なるものは除かれており、厳密に遷移後のパスが網羅されているわけではないが、\coqi{path_perm}によってこの問題は考えなくてよくなっている。

この補題を使うと、遷移パスの制約の追加をCoqの計算に任せることができる。

\section{証明}

TBD
