\chapter{アクターモデルの形式化}
\label{chapter:formalization}

本章では、Actarioにおいてアクターモデルをどのように形式化を行っているかということを説明する。
まず、意味論の形式化、そして名前付けの方法、その名前付けの方法が一意な名前を生成するということの証明の説明を行う。


\section{意味論の形式化}

アクターモデルの操作的意味をconfigurationのラベル付き遷移システムとして定式化する。
これ以降用いる記号を図\ref{expr:formalization:config}と定義する。また、Actarioではこれは図\ref{code:formalization:config}と定義している。

\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\textit{Configuration}]
  アクターシステムの配置を表す。実体はアクターの集合である。
\item[\textit{Actor}]
  アクターを表す。アクターの名前、まだ実行していないアクションの列、生成番号、振る舞いのテンプレート、メッセージキューから成る。
\item[\textit{Name}]
  アクターの名前を表す。名前は、トップレベルのアクターか、生成されたアクターのどちらかであるかを表す。トップレベルのアクターとはつまり親アクターがいないアクターであり、システムの名称を表す文字列を引数にとる。また、トップレベルのアクターをトップレベルアクターと呼ぶ。生成されたアクターは、親アクターの名前と、その親アクターが何番目に生成したアクターかを表す自然数(これを世代番号と呼ぶ)を引数にとる。
\item[\textit{Message}]
  メッセージは、アクターの名前、基本的なデータ型(自然数、文字列)、およびその組み合わせ(タプル)から構成される。
\item[\textit{Behavior State}]
  アクターの振る舞いを表す。メッセージを受け取り、アクションの列を返す関数である。
\item[\textit{Actions State}]
  アクターのアクションの列を表す。アクションには、他のアクターにメッセージを送る\textsf{send}、新しくアクターを生成する\textsf{new}、自分自身の名前を得る\textsf{self}、新しい状態になり次のメッセージの待ち状態になる\textsf{become}の4つがある。
  \textsf{become}以外の各アクションは、最後の引数にこのアクションの継続を表すものをとる。つまり、メッセージの処理は必ず\textsf{become}で終わることになる。
  また、ここでの\textit{State}は型引数であり、\textsf{become}の引数はこの型の値でなければならない。
\item[\textit{Label}]
  遷移システムのラベルを表す。\textsf{Receive}、\textsf{Send}、\textsf{New}、\textsf{Self}はそれぞれ消費したアクションが\textsf{become}、\textsf{send}、\textsf{new}、\textsf{self}であったときのラベルである。
\end{description}


\begin{figure}[t]
  \begin{displaymath}
    \begin{array}{rclcl}
      c & \in & \textit{Configuration} & =   & \textit{Set Actor} \\
      a & \in & \textit{Actor}  & =   & \textit{Name} \times \textit{Actions State} \times \mathbb{N} \times \\
        &     &                 &     & (\textit{State} \rightarrow \textit{Behavior State}) \times \textit{List Message} \\
      n & \in & \textit{Name}   & ::= & \textsf{toplevel}(str) \\
        &     &                 &   | & \textsf{generated}(g, n) \\
      m & \in & \textit{Message} & =  & \textit{Name} + \textit{PrimVal} + \\
        &     &                 &     & \textit{Message} \times \cdots \times \textit{Message} \\
      b & \in & \textit{Behavior State} & = & \textit{Message} \rightarrow \textit{Actions State} \\
      \alpha & \in & \textit{Actions State} & ::= & \textsf{send}(n, m, \alpha) \\
        &     &                 &   | & \textsf{new}(t, s, \kappa) \\
        &     &                 &   | & \textsf{self}(\kappa) \\
        &     &                 &   | & \textsf{become}(s) \\
      l & \in & \textit{Label}  & ::= & \textsf{Receive}(n, m) \\
        &     &                 &   | & \textsf{Send}(n, n, m) \\
        &     &                 &   | & \textsf{New}(n) \\
        &     &                 &   | & \textsf{Self}(n) \\
      \kappa & \in & \textit{Name} \rightarrow \textit{Actions State} \\
      s & \in & \textit{State} & & \\
      g & \in & \mathbb{N} & & \\
      t & \in & \textit{State} \rightarrow \textit{Behavior State} \\
      q & \in & \textit{List Message}
      str & \in & \textit{String}
    \end{array}
  \end{displaymath}
  \caption{記号の定義}\label{expr:formalization:config}
\end{figure}


\begin{figure}
  \lstinputlisting{./code/formalization/config.v}
  \label{code:formalization:config}
  \caption{Actarioでの記号の定義}
\end{figure}

\begin{figure}[t]\centering
  \begin{displaymath}
    \begin{array}{rcl}
      c \cup \{(n_{\textrm{to}}, \textsf{become}(s), g, t, q)\} &
      \overset{\textsf{Receive}(n_{\textrm{to}}, m)}{\leadsto} &
      c \cup \{(n_{\textrm{to}}, t(s)(m), g, t, q)\}
      \hfill \textsc{(Receive)} \\[2ex]

      c \cup \{(n_{\textrm{from}}, \textsf{send}(n_{\textrm{to}}, m, \alpha), g, t, q),
      & &
      c \cup \{(n_{\textrm{from}}, \alpha, g, t, q), \\
      (n_{\textrm{to}}, \alpha', g', t', q')\} &
      \overset{\textsf{Send}(n_{\textrm{from}}, n_{\textrm{to}}, m)}{\leadsto} &
      \hspace{5ex} (n_{\textrm{to}}, \alpha', g', t', q' \doubleplus [m])\}
      \hfill \textsc{(Send)} \\[2ex]

      & & c \cup \{(n, \kappa(n'), g + 1, t, q), \\
      c \cup \{(n, \textsf{new}(t', s, \kappa), g, t, q)\} &
      \overset{\textsf{New}(n')}{\leadsto} &
      \hspace{5ex} (n', \textsf{become}(s), 0, t', [])\} \\
      & & \textrm{where}\ n' := \textsf{generated}(g, n)
      \hfill \textsc{(New)} \\[2ex]

      c \cup \{(n, \textsf{self}(\kappa), g, t, q)\} &
      \overset{\textsf{Self}(n)}{\leadsto} &
      c \cup \{(n, \kappa(n), g, t, q)\}
      \hfill \textsc{(Self)}
    \end{array}
  \end{displaymath}
  \caption{ラベル付き遷移システム}\label{expr:formalization:semantics}
\end{figure}

\section{名前付け}

アクターの名前は一意になる。
一般的なアクターの実装では、一意な名前付けと名前の管理をするために、副作用を使った名前付けを行うことが多い。例えば、グローバル変数に自然数を持っておき、名前を生成する度にインクリメントする方法や、アクターのメモリのアドレスをアクターの名前にしてしまう方法がある。
しかし、Coqのような副作用を記述できない純粋な言語では、一意な名前付けは問題になりやすい。
Actarioでは、アクターの名前を、親の名前とその親が何番目に生成したアクターかを表す自然数のペアで表現することで、一意な名前付けを実現している。

\subsection{名前の一意性の証明}

この意味論と名前付けの方法によって生成された名前は必ず一意になるということを証明する。
これを証明するために、名前に関する\textit{trans invariant}という遷移の間で変わらない性質を定義する。
trans invariant は以下のように3つの述語\texttt{chain}, \texttt{gen\_fresh}, \texttt{no\_dup}の組で定義される。

\begin{displaymath}
  \begin{array}{l}
    \texttt{trans\_invariant}(c) := \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c)
  \end{array}
\end{displaymath}

\texttt{chain}, \texttt{gen\_fresh}, \texttt{no\_dup}の簡単な説明は以下のとおりである。

\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{chain}]
  配置内の各アクターについて、そのアクターが他のアクターから生成されたものであるなら親アクターはその配置に存在している。
\item[\texttt{gen\_fresh}]
  配置内の各アクターについて、そのアクターが次に生成するアクターの名前は配置内で新しい名前である。
\item[\texttt{no\_dup}]
  配置内のすべてのアクターの名前は一意である。
\end{description}

\subsubsection{Functions}

証明の説明に入る前に、この節で用いる関数をいくつか定義する。


\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{actors} $: \textit{Configuration} \rightarrow \textit{Set(Actor)}$]
  配置を受け取り、配置を構成するアクターの集合を返す。
\item[\texttt{parent} $: \textit{Actor} \rightarrow \textit{Actor}$]
  アクターを受け取り、そのアクターの親アクターを返す。親がいない場合は、\texttt{nothing} を返す。
\item[\texttt{gen\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  アクターを受け取り、そのアクターの名前の生成番号を返す。(generation number と generated number 生成番号の定義？)
  トップレベルアクターの場合は、\texttt{nothing} を返す。
\item[\texttt{next\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  アクターを受け取り、そのアクターが次に生成する番号を返す。
\item[\texttt{name} $: \textit{Actor} \rightarrow \textit{Name}$]
  アクターを受け取り、そのアクターの名前を返す。
\item[\texttt{names} $: \textit{Set(Actor)} \rightarrow \textit{Set(Name)}$]
  アクターの集合を受け取り、その集合の各アクターの名前の集合を返す。
\end{description}

\subsubsection{連鎖性}

連鎖性(chain)という、配置に関する述語を定義する。
連鎖性とは、配置の中に含まれるアクターについて、そのアクターが他のアクターによって生成されたものであるならば、そのアクターも配置の中に含まれる、という述語である。
つまり、トップレベルアクターを頂点とする木になるということである。(TODO:言い方。頂点？)
ここで、トップレベルアクターが複数ある場合でも、(仲間はずれの)アクターが存在しなければ連鎖性は成り立つということに注意されたい。
連鎖性は以下のように定義される。

\begin{displaymath}
  \begin{array}{l}
    \texttt{chain}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p, p = \texttt{parent}(a) \Rightarrow p \in \texttt{actors}(c)
  \end{array}
\end{displaymath}

ここで、任意の遷移について連鎖性は保存される連鎖保存性を証明する。
証明は遷移のラベルによる場合分けで行う。
連鎖性はアクターの名前によってのみで決定され、かつ名前が変更されうる遷移ラベルは\textsc{New}しかないので、\textsc{New}のみ考えればよい。

\begin{lemma}{連鎖保存性}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{chain}(c')
  \end{array}
\end{displaymath}
\end{lemma}

連鎖保存性の証明は図\ref{code:formalization:chain-preservation}による。

\begin{figure}[tp]
  \lstinputlisting{./code/formalization/chain_preservation.v}
  \label{code:formalization:chain-preservation}
  \caption{連鎖保存性の証明}
\end{figure}

\subsubsection{新鮮性}

We define \texttt{gen\_fresh} predicate that, for each actor in the configuration, the name of its child is always fresh.
The definition of \texttt{gen\_fresh} is complicated a little.
We translate the proposition that next generated name is fresh to the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{gen\_fresh}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p \in \texttt{actors}(c), p = \texttt{parent}(a) \Rightarrow \\
    \quad \quad \quad \texttt{gen\_number}(a) < \texttt{next\_number}(p)
  \end{array}
\end{displaymath}


It is guaranteed that the actor name generated in the next is fresh if satisfying \texttt{gen\_fresh} predicate by the relation of next generation numbers and actor names. %% For each actor in the configuration, if its parent is in the configuration, the next generation number of the parent actor is greater than the generation number of the name of the child actor.
However, the actor name generated after the next is not always fresh name.
For example, if there are two actors ($A$ and $B$) that have the same name and the same next generation number and actor $A$ generates a child actor and actor $B$ generates a child actor, although \texttt{gen\_fresh} holds, these child actors have the same name.
Furthermore, if the parent of the actor $A$ does not exist in the configuration and the parent of the parent exists in the configuration, and the parent of the parent actor generates an actor and it also generates an actor, then the name is possible to have the same as $A$'s one.

つまり、あるアクターについて、システム内に親アクターがいる場合、親アクターが次に生成する番号は自分の番号よりも大きい、ということにより、次に生成するアクターの名前が被らないようになっている。
ただし、次に生成するアクターの名前は fresh でもその次に生成するアクターは fresh ではないこともある。
例えば、同じ名前でかつ次の generation number も同じという2つのアクターがいた場合、まず片方のアクターが生成するアクターの名前は fresh だが、その次にもう片方のアクターがアクターを生成したとすると、名前が被ってしまう。
また、親アクターがシステム内に存在せずに、親の親は存在しているという場合、親の親が次に生成するアクターの名前は被らないが、その子アクターが次に生成する名前は被ってしまう可能性がある。(図？)

Thus, to prove \textit{gen fresh preservation} proposition that \texttt{gen\_fresh} is preserved between transitions, it is necessary to use \texttt{chain} and \texttt{no\_dup} as hypotheses.
%% The proof is by ...
%% 以上のように gen\_fresh だけでは gen\_fresh を導けないので、gen\_fresh の証明には chain と no\_dup の性質が必要になる。

\begin{lemma}{gen fresh preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
    \quad \texttt{gen\_fresh}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsubsection{一意性}

一意性(\texttt{no\_dup})を定義する。
一意性は、与えられた配置のすべてのアクターの名前が一意であるという述語である。
これは最終的に証明したい名前の一意性の定義と同じである。
一意性は以下のように定義できる。

\begin{displaymath}
  \begin{array}{l}
    \texttt{no\_dup}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \texttt{name}(a) \notin
    \texttt{names}(\texttt{actors}(c) \setminus \{a\})
  \end{array}
\end{displaymath}

連鎖保存性、新鮮保存性と同様に、一意保存性も定義する。

\begin{lemma}{一意保存性}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{no\_dup}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsubsection{名前の一意性の証明}

この意味論によって動的に生成される名前が一意になるということの証明を行う。
まず、遷移の間で遷移不変性が保存されるという遷移不変保存性(trans invariant preservation)を証明する。
遷移不変性は連鎖性、新鮮性、一意性から成るので、遷移不変保存性は明らかに成り立つ。

\begin{lemma}{遷移不変保存性}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}

次に初期状態について遷移不変性が成り立っていれば、任意回の遷移後も遷移不変性が成り立つということをを証明する。

\begin{lemma}{遷移不変性(star)}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}

$c \overset{l}{\leadsto\star} c'$ represents reflexive transitive closure of transition.
The proof is by induction of reflexive transitive closure of transition and trans invariant preservation.

Finally, we can prove name uniqueness.
\begin{theorem}{name uniqueness}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \texttt{no\_dup}(c')
    \end{array}
  \end{displaymath}
\end{theorem}
This is obvious by trans invariant preservation star because \texttt{no\_dup} is in \texttt{trans\_invariant}.
