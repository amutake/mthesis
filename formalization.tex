\chapter{アクターモデルの形式化}
\label{chapter:formalization}

本章では、Actarioにおいてアクターモデルをどのように形式化を行っているかということを説明する。
まず、意味論の形式化、名前付け、
障害と回復、fairnessの形式化

\section{意味論の形式化}

まずアクターモデルの操作的意味論の形式化をCoqで行う。

アクターの名前

配置(configuration)は

アクターモデルの操作的意味をconfigurationのラベル付き遷移システムとして定式化する。
これ以降用いる記号を図~\ref{expr:formalization:config}のように定義する。

\begin{figure}[t]
  \begin{displaymath}
    \begin{array}{rclcl}
      c & \in & \textit{Configuration} & =   & \textit{Set(InFlight)} \times \textit{Set(Actor)} \\
      a & \in & \textit{Actor}  & =   & \textit{Name} \times \textit{Actions} \times \mathbb{N} \\
      n & \in & \textit{Name}   & ::= & \textsf{toplevel}(s) \\
        &     &                 &   | & \textsf{generated}(g, n) \\
      m & \in & \textit{Message} & =  & \textit{Name} + \textit{PrimVal} + \\
        &     &                 &     & \textit{Message} \times \cdots \times \textit{Message} \\
      i & \in & \textit{InFlight} & = & \textit{Name} \times \textit{Name} \times \textit{Message} \\
      b & \in & \textit{Behavior} & = & \textit{Message} \rightarrow \textit{Actions} \\
      \alpha & \in & \textit{Actions} & ::= & \textsf{send}(n, m, \alpha) \\
        &     &                 &   | & \textsf{new}(b, \kappa) \\
        &     &                 &   | & \textsf{self}(\kappa) \\
        &     &                 &   | & \textsf{become}(b) \\
      l & \in & \textit{Label}  & ::= & \textsf{Receive}(n, n, m) \\
        &     &                 &   | & \textsf{Send}(n, n, m) \\
        &     &                 &   | & \textsf{New}(n) \\
        &     &                 &   | & \textsf{Self}(n) \\
      \kappa & \in & \textit{Name} \rightarrow \textit{Actions} \\
      g & \in & \mathbb{N} & &
    \end{array}
  \end{displaymath}
  \caption{Configuration}\label{expr:formalization:config}
\end{figure}


\begin{figure}[t]
  \begin{displaymath}
    \begin{array}{rcl}
      (I \uplus \{(n_{\textrm{to}}, n_{\textrm{from}}, m)\}, A \cup \{(n_{\textrm{to}}, \textsf{become}(b), g)\}) &
      \overset{\textsf{Receive}(n_{\textrm{to}}, n_{\textrm{from}}, m)}{\leadsto} &
      (I, A \cup \{(n_{\textrm{to}}, b(m), g)\})
      \hfill \textsc{(Receive)} \\[1ex]

      (I, A \cup \{(n_{\textrm{from}}, \textsf{send}(n_{\textrm{to}}, m, \alpha), g)\}) &
      \overset{\textsf{Send}(n_{\textrm{from}}, n_{\textrm{to}}, m)}{\leadsto} &
      (I \uplus \{(n_{\textrm{to}}, n_{\textrm{from}}, m)\}, A \cup \{(n_{\textrm{from}}, \alpha, g)\}) \\
      & & \hfill \textsc{(Send)} \\[1ex]

      (I, A \cup \{(n, \textsf{new}(b, \kappa), g)\}) &
      \overset{\textsf{New}(n')}{\leadsto} &
      (I, A \cup \{(n, \kappa(n'), g + 1), (n', \textsf{become}(b), 0)\}) \\
      & & \hfill \textrm{where}\ n' := \textsf{generated}(g, n) \\
      & & \hfill \textsc{(New)} \\[1ex]

      (I, A \cup \{(n, \textsf{self}(\kappa), g)\}) &
      \overset{\textsf{Self}(n)}{\leadsto} &
      (I, A \cup \{n, \kappa(n), g\})
      \hfill \textsc{(Self)}
    \end{array}
  \end{displaymath}
  \caption{labeled transition semantics}\label{expr:formalization:semantics}
\end{figure}



\subsection{名前の一意性の証明}

この名前付けの方法によって生成された名前は必ず一意になるということを証明する。
これを証明するために、名前に関する\textit{trans invariant}という遷移の間で変わらない性質を定義する。
trans invariant は以下のように3つの述語\texttt{chain}, \texttt{gen\_fresh}, \texttt{no\_dup}の組で定義される。

\begin{displaymath}
  \begin{array}{l}
    \texttt{trans\_invariant}(c) := \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c)
  \end{array}
\end{displaymath}

\texttt{chain}, \texttt{gen\_fresh}, \texttt{no\_dup}の簡単な説明は以下のとおりである。

\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{chain}]
  配置の各アクターについて、そのアクターが他のアクターから生成されたものであるなら親アクターはその配置に存在している。
\item[\texttt{gen\_fresh}]
  配置の各アクターについて、そのアクターが次に生成するアクターの名前は配置内で新しい名前である。
\item[\texttt{no\_dup}]
  配置のすべてのアクターの名前は一意である。
\end{description}

\subsubsection{Functions}

証明の説明に入る前に、この節で用いる関数をいくつか定義する。


\begin{description}[style=nextline,leftmargin=12pt,parsep=0pt]
\item[\texttt{actors} $: \textit{Configuration} \rightarrow \textit{Set(Actor)}$]
  配置を受け取り、配置を構成するアクターの集合を返す。
\item[\texttt{parent} $: \textit{Actor} \rightarrow \textit{Actor}$]
  アクターを受け取り、そのアクターの親アクターを返す。親がいない場合は、\texttt{nothing} を返す。
\item[\texttt{gen\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  アクターを受け取り、そのアクターの名前の生成番号を返す。(generation number と generated number 生成番号の定義？)
  トップレベルアクターの場合は、\texttt{nothing} を返す。
\item[\texttt{next\_number} $: \textit{Actor} \rightarrow \mathbb{N}$]
  アクターを受け取り、そのアクターが次に生成する番号を返す。
\item[\texttt{name} $: \textit{Actor} \rightarrow \textit{Name}$]
  アクターを受け取り、そのアクターの名前を返す。
\item[\texttt{names} $: \textit{Set(Actor)} \rightarrow \textit{Set(Name)}$]
  アクターの集合を受け取り、その集合の各アクターの名前の集合を返す。
\end{description}

\subsubsection{連鎖性}

連鎖性(chain)という、配置に関する述語を定義する。
連鎖性とは、配置の中に含まれるアクターについて、そのアクターが他のアクターによって生成されたものであるならば、そのアクターも配置の中に含まれる、という述語である。
つまり、トップレベルアクターを頂点とする木になるということである。(TODO:言い方。頂点？)
ここで、トップレベルアクターが複数ある場合でも、(仲間はずれの)アクターが存在しなければ連鎖性は成り立つということに注意されたい。
連鎖性は以下のように定義される。

\begin{displaymath}
  \begin{array}{l}
    \texttt{chain}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p, p = \texttt{parent}(a) \Rightarrow p \in \texttt{actors}(c)
  \end{array}
\end{displaymath}

ここで、任意の遷移について連鎖性は保存される連鎖保存性を証明する。
証明は遷移のラベルによる場合分けで行う。
連鎖性はアクターの名前によってのみで決定され、かつ名前が変更されうる遷移ラベルは\textsc{New}しかないので、\textsc{New}のみ考えればよい。

\begin{lemma}{連鎖保存性}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{chain}(c')
  \end{array}
\end{displaymath}
\end{lemma}

連鎖保存性の証明は図\ref{code:formalization:chain-preservation}による。

\begin{figure}[tp]
  \lstinputlisting{./code/formalization/chain_preservation.v}
  \label{code:formalization:chain-preservation}
  \caption{連鎖保存性の証明}
\end{figure}

\subsubsection{新鮮性}


We define \texttt{gen\_fresh} predicate that, for each actor in the configuration, the name of its child is always fresh.
The definition of \texttt{gen\_fresh} is complicated a little.
We translate the proposition that next generated name is fresh to the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{gen\_fresh}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \forall p \in \texttt{actors}(c), p = \texttt{parent}(a) \Rightarrow \\
    \quad \quad \quad \texttt{gen\_number}(a) < \texttt{next\_number}(p)
  \end{array}
\end{displaymath}


It is guaranteed that the actor name generated in the next is fresh if satisfying \texttt{gen\_fresh} predicate by the relation of next generation numbers and actor names. %% For each actor in the configuration, if its parent is in the configuration, the next generation number of the parent actor is greater than the generation number of the name of the child actor.
However, the actor name generated after the next is not always fresh name.
For example, if there are two actors ($A$ and $B$) that have the same name and the same next generation number and actor $A$ generates a child actor and actor $B$ generates a child actor, although \texttt{gen\_fresh} holds, these child actors have the same name.
Furthermore, if the parent of the actor $A$ does not exist in the configuration and the parent of the parent exists in the configuration, and the parent of the parent actor generates an actor and it also generates an actor, then the name is possible to have the same as $A$'s one.

つまり、あるアクターについて、システム内に親アクターがいる場合、親アクターが次に生成する番号は自分の番号よりも大きい、ということにより、次に生成するアクターの名前が被らないようになっている。
ただし、次に生成するアクターの名前は fresh でもその次に生成するアクターは fresh ではないこともある。
例えば、同じ名前でかつ次の generation number も同じという2つのアクターがいた場合、まず片方のアクターが生成するアクターの名前は fresh だが、その次にもう片方のアクターがアクターを生成したとすると、名前が被ってしまう。
また、親アクターがシステム内に存在せずに、親の親は存在しているという場合、親の親が次に生成するアクターの名前は被らないが、その子アクターが次に生成する名前は被ってしまう可能性がある。(図？)

Thus, to prove \textit{gen fresh preservation} proposition that \texttt{gen\_fresh} is preserved between transitions, it is necessary to use \texttt{chain} and \texttt{no\_dup} as hypotheses.
%% The proof is by ...
%% 以上のように gen\_fresh だけでは gen\_fresh を導けないので、gen\_fresh の証明には chain と no\_dup の性質が必要になる。

\begin{lemma}{gen fresh preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{chain}(c) \wedge \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
    \quad \texttt{gen\_fresh}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsubsection{No Dup Property}
We define \texttt{no\_dup} predicate that all actor names in the given configuration are unique.
This is the property we have to prove.
\texttt{no\_dup} is defined as the following.

\begin{displaymath}
  \begin{array}{l}
    \texttt{no\_dup}(c) := \\
    \quad \forall a \in \texttt{actors}(c), \texttt{name}(a) \notin
    \texttt{names}(\texttt{actors}(c) \setminus \{a\})
  \end{array}
\end{displaymath}

We proved \textit{no dup preservation} property defined as the following.
It represents that if the actor names in the configuration is not duplicate and the next generated actor name is fresh, then \texttt{no\_dup} holds in the next configuration.

\begin{lemma}{no dup preservation}
\begin{displaymath}
  \begin{array}{l}
    \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
    \quad \texttt{gen\_fresh}(c) \wedge \texttt{no\_dup}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \texttt{no\_dup}(c')
  \end{array}
\end{displaymath}
\end{lemma}

\subsubsection{Proof of Name Uniqueness Property}
Then, we start to prove name uniqueness.
First, we prove trans invariant preservation that trans invariant is preserved between transitions.
This is obvious by chain preservation, gen fresh preservation and no dup preservation.
\begin{lemma}{trans invariant preservation}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}

Next, we prove that if trans invariant holds in initial configuration, trans invariant holds after arbitrary transitions.

%% 次に初期状態について trans\_invariant が成り立っていれば、任意回の遷移後も trans\_invariant が成り立つということをを証明する。

\begin{lemma}{trans invariant preservation star}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \\
      \quad \texttt{trans\_invariant}(c')
    \end{array}
  \end{displaymath}
\end{lemma}
$c \overset{l}{\leadsto\star} c'$ represents reflexive transitive closure of transition.
The proof is by induction of reflexive transitive closure of transition and trans invariant preservation.

Finally, we can prove name uniqueness.
\begin{theorem}{name uniqueness}
  \begin{displaymath}
    \begin{array}{l}
      \forall c, c' \in \textit{Configuration}, \forall l \in \textit{Label}, \\
      \quad \texttt{trans\_invariant}(c) \wedge c \overset{l}{\leadsto\star} c' \Rightarrow \texttt{no\_dup}(c')
    \end{array}
  \end{displaymath}
\end{theorem}
This is obvious by trans invariant preservation star because \texttt{no\_dup} is in \texttt{trans\_invariant}.


\section{障害と回復の形式化}

\section{Fairnessの形式化}

Fairnessとは、アクターモデルが持つ性質で、発火する(?)可能性があるものはいつか発火されるというものである。
通常、Fairnessを表現する際には時相論理が必要になるが、Coqは時相論理はサポートしていない。
そのため、配置の遷移列である遷移パスを使ってFairnessを表現する。
この手法はAppl$\pi$\cite{}で用いられている手法である。Appl$\pi$は$\pi$計算のためのライブラリであるが、Fairnessの定義方法についてはアクターモデルに対しても同様に用いることができる。

\subsection{遷移パス}
遷移パスは自然数$\mathbb{N}$から\texttt{option config}型への関数として定義する (図~\ref{code:formalization:path})。
定義域の自然数は、初期状態から何回目の遷移によってこの配置になったかという番号である。この番号をインデックスと呼ぶ。
値域はそのインデックスに対応する配置を表す。\texttt{config}型ではなく\texttt{option config}型になっているのは、これ以上遷移ができないパスも表したいからである。つまり、これ以上遷移ができない配置のインデックスを$n$とすると、$\forall m > 0, n + m$に遷移パス関数を適用した結果は\texttt{None}になる。

\begin{figure}[tp]
  \begin{lstlisting}
    Definition path := nat -> option config.
  \end{lstlisting}
  \label{code:formalization:path}
  \caption{遷移パスの定義}
\end{figure}

また、与えられた遷移パスが確かに遷移パスとしての仕様を満たしているか、という述語を定義する(図~\ref{code:formalization:path-spec})。
すべてのインデックス$i$について、$i$番目の配置が存在するならば、$i+1$番目の配置が存在するならそれは遷移できるものか、それ以上遷移できない。$i$番目の配置が存在しないならば、その次の配置も存在しない、という意味である。

\begin{figure}[tp]
  \begin{lstlisting}
Definition is_transition_path (p : path) : Prop :=
  forall n,
    (forall c, p n = Some c ->
      (exists c' l, p (S n) = Some c' /\
        c ~(l)~> c') \/
      p (S n) = None) /\
    (p n = None -> p (S n) = None).
  \end{lstlisting}
  \label{code:formalization:path-spec}
  \caption{遷移パスの仕様}
\end{figure}

\subsection{遷移可能性}
次に、与えられた配置が与えられたラベルでもって遷移ができるという述語を定義する。これを遷移可能性(enabled)と呼ぶ。
Actarioでは、遷移可能性はある配置からあるラベルによって遷移した先の配置が存在すると定義する (図~\ref{code:formalization:enabled})。

\begin{figure}[tp]
  \begin{lstlisting}
Definition enabled (c : config) (l : label) : Prop := exists c', c ~(l)~> c'.
  \end{lstlisting}
  \label{code:formalization:enabled}
  \caption{遷移可能性}
\end{figure}

\subsection{Infinitely Often Enabled}
無限にしばしば遷移可能になる
We define the predicate that the transition is infinitely often enabled in the transition path.
It is named \texttt{infinitely often enabled}.
%% これは、すべての index n について、n 番目の configuration があるラベルによって遷移が可能ならば、その先そのラベルによって遷移が可能になる configuration が存在する、と定義する。

\begin{lstlisting}
Definition infinitely_often_enabled
    (l : label) (p : path) : Prop :=
  forall n c, p n = Some c ->
    enabled c l ->
    exists m c', m > n /\
      p m = Some c' /\
      enabled c' l.
\end{lstlisting}


\subsection{Eventually Processed}
We define \texttt{eventually processed} that is the predicate of label and transition path.
It represents that the transition with the label is processed eventually in the path.
It is defined as follows.

\begin{lstlisting}
Definition eventually_processed
    (l : label) (p : path) : Prop :=
  exists n c c',
    p n = Some c /\
    p (S n) = Some c' /\
    c ~(l)~> c'.
\end{lstlisting}


\subsection{Fairness}
遷移パスに対して\texttt{fairness}という述語、図~\ref{code:formalization:fairness}のように定義できる。

For the given transition path and for each label, if \texttt{infinitely often enabled} holds, then \texttt{eventually processed} holds.
\texttt{is\_postfix\_ of} という述語は、無限を表すために使われており、。

If \texttt{is postfix of} is not used, the transition may not be processed after the transition is processed although the transition is processed in whole the path.
To prevent it, if \texttt{inifinitely often enabled} holds then \texttt{eventually processed} holds for arbitrary postfix path by using \texttt{is postfix path}.

\begin{figure}[tp]
  \begin{lstlisting}
  Definition is_postfix_of (p' p : path) : Prop :=
    exists n, (forall m, p' m = p (m + n)).

  Definition fairness : Prop :=
    forall p p', is_postfix_of p' p ->
      (forall l,
        infinitely_often_enabled l p' ->
        eventually_processed l p').
  \end{lstlisting}
  \label{code:formalization:fairness}
  \caption{fairnessの定義}
\end{figure}
